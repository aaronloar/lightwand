/*
 ********************************************************************************
 ** File:  startup.c
 **
 ** Description:
 ** This file sets up the microcontroller vector table, stack, heap, and data
 ** locations.  It then passes control to main().
 ********************************************************************************
 ** DJB 11/17/13 Created
 ********************************************************************************
 */

//Project-wide #includes
#include "universal.h"

//Reflective #includes
#include "startup.h"

//System #includes
//None

//Project #includes
//None

//------------------------------------------------------------------------------
//Global variables
//The following symbols are constructs generated by the linker, indicating the
//location of various points in the "Global Section Table".  This table is
//created by the linker via the managed linker script mechanism.  It contains the
//load address, execution address and length of each RW data section and the
//execution and length of each BSS (zero initialized) section.
extern unsigned int __data_section_table;
extern unsigned int __data_section_table_end;
extern unsigned int __bss_section_table;
extern unsigned int __bss_section_table_end;

//Functions
/*------------------------------------------------------------------------------
 * Function name:  Array of Function Pointers
 * Function Description:  Initializes the vector table with the stack pointer and
 * 						 addresses for vectors.  This relies on the linker
 * 						 script to place at correct location in memory.
 * Parameters:
 * functionVectors - Array of pointers to the functions in the vector table.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".isr_vector")))
void (* const functionVectors[])(void) = {
    &_vStackTop,                    //Initial stack pointer
    reset_handler,                  //Reset vector
    nmi_handler,                    //Non maskable interrupt vector
    hardfault_handler,              //All class of fault vector
    memmanage_handler,              //Memory management vector
    busfault_handler,               //Pre-fetch fault, memory access fault vector
    usagefault_handler,             //Undefined instruction or illegal state vector
    0,                              //Reserved
    0,                              //Reserved
    0,                              //Reserved
    0,                              //Reserved
    svc_handler,                    //System service call via SWI instruction vector
    debugmon_handler,               //Debug monitor vector
    0,                              //Reserved
    pendsv_handler,                 //Penable request for system service vector
    systick_handler,                //System tick timer vector
    window_watchdog_irq_handler,    //Window watchdog interrupt vector
    pvd_irq_handler,                //PVD through EXTI line detection interrupt vector
    tamper_stamp_irq_handler,       //Tamper and TimeStamp through EXTI line interrupts vector
    rtc_wakeup_irq_handler,         //RTC Wakeup through EXTI line interrupt vector
    flash_irq_handler,              //Flash global interrupt vector
    rcc_irq_handler,                //RCC Global interrupt vector
    exti0_irq_handler,              //EXTI Line 0 interrupt vector
    exti1_irq_handler,              //EXTI Line 1 interrupt vector
    exti2_irq_handler,              //EXTI Line 2 interrupt vector
    exti3_irq_handler,              //EXTI Line 3 interrupt vector
    exti4_irq_handler,              //EXTI Line 4 interrupt vector
    dma1_channel1_irq_handler,      //DMA1 Channel 1 global interrupt vector
    dma1_channel2_irq_handler,      //DMA1 Channel 2 global interrupt vector
    dma1_channel3_irq_handler,      //DMA1 Channel 3 global interrupt vector
    dma1_channel4_irq_handler,      //DMA1 Channel 4 global interrupt vector
    dma1_channel5_irq_handler,      //DMA1 Channel 5 global interrupt vector
    dma1_channel6_irq_handler,      //DMA1 Channel 6 global interrupt vector
    dma1_channel7_irq_handler,      //DMA1 Channel 7 global interrupt vector
    adc1_irq_handler,               //ADC1 Global interrupt vector
    0,                              //Reserved
    0,                              //Reserved
    0,                              //Reserved
    0,                              //Reserved
    exti9_5_irq_handler,            //ETXI Line[9:5] interrupts vector
    tim1_brk_tim15_irq_handler,     //TIM1 Break and TIM15 global interrupts vector
    tim1_up_tim16_irq_handler,      //TIM1 Update and TIM16 global interrupts vector
    tim1_trg_com_tim17_irq_handler, //TIM1 Trigger and Commutation and TIM17 global interrupts vector
    tim1_cc_irq_handler,            //TIM1 Capture compare interrupt vector
    tim2_irq_handler,               //TIM2 Global interrupt vector
    tim3_irq_handler,               //TIM3 Global interrupt vector
    tim4_irq_handler,               //TIM4 Global interrupt vector
    i2c1_ev_irq_handler,            //I2C1 Event interrupt vector
    i2c1_er_irq_handler,            //I2C1 Error interrupt vector
    i2c2_ev_irq_handler,            //I2C2 Event interrupt vector
    i2c2_er_irq_handler,            //I2C2 Error interrupt vector
    spi1_irq_handler,               //SPI1 Global interrupt vector
    spi2_irq_handler,               //SPI2 Global interrupt vector
    usart1_irq_handler,             //USART1 Global interrupt vector
    usart2_irq_handler,             //USART2 Global interrupt vector
    usart3_irq_handler,             //USART3 Global interrupt vector
    exti15_10_irq_handler,          //EXTI Line[15:10] interrupts vector
    rtc_alarm_irq_handler,          //RTC Alarms (A and B) through EXTI line interrupt vector
    cec_irq_handler,                //CEC Global interrupt vector
    tim12_irq_handler,              //TIM12 Global interrupt vector
    tim13_irq_handler,              //TIM13 Global interrupt vector
    tim14_irq_handler,              //TIM14 Global interrupt vector
    0,                              //Reserved
    0,                              //Reserved
    fsmc_irq_handler,               //FSMC Global interrupt vector
    0,                              //Reserved
    tim5_irq_handler,               //TIM5 Global interrupt vector
    spi3_irq_handler,               //SPI3 Global interrupt vector
    uart4_irq_handler,              //UART4 Global interrupt vector
    uart5_irq_handler,              //UART5 Global interrupt vector
    tim6_dac_irq_handler,           //TIM6 Global and DAC underrun interrupts vector
    tim7_irq_handler,               //TIM7 Global interrupt vector
    dma2_channel1_irq_handler,      //DMA2 Channel 1 global interrupt vector
    dma2_channel2_irq_handler,      //DMA2 Channel 2 global interrupt vector
    dma2_channel3_irq_handler,      //DMA2 Channel 3 global interrupt vector
    dam2_channel4_5_irq_handler,    //DMA2 Channels 4 and 5 global interrupts vector
};

/*------------------------------------------------------------------------------
 * Function name:  data_init
 * Function Description:  Initializes the RW data section.
 * Parameters:
 * romStart -
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int romstart, unsigned int start, unsigned int len)
{
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int *pulSrc = (unsigned int*) romstart;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
        *pulDest++ = *pulSrc++;
}

/*------------------------------------------------------------------------------
 * Function name:  data_init
 * Function Description:  Initializes the BSS data section.
 * Parameters:
 * romStart -
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int start, unsigned int len)
{
    unsigned int *pulDest = (unsigned int*) start;
    unsigned int loop;
    for (loop = 0; loop < len; loop = loop + 4)
        *pulDest++ = 0;
}

/*------------------------------------------------------------------------------
 * Function name:  reset_handler
 * Function Description:  Reset entry point.  Initializes the MCU.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void reset_handler(void)
{
    //Copy the data sections from flash to SRAM.
    unsigned int LoadAddr, ExeAddr, SectionLen;
    unsigned int *SectionTableAddr;

    //Load base address of Global Section Table.
    SectionTableAddr = &__data_section_table;

    //Copy the data sections from flash to SRAM.
    while (SectionTableAddr < &__data_section_table_end) {
        LoadAddr = *SectionTableAddr++;
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        data_init(LoadAddr, ExeAddr, SectionLen);
    }

    //Zero fill the bss segment.
    SectionTableAddr = &__bss_section_table;
    while (SectionTableAddr < &__bss_section_table_end) {
        ExeAddr = *SectionTableAddr++;
        SectionLen = *SectionTableAddr++;
        bss_init(ExeAddr, SectionLen);
    }

    //Setup the system and bus clocks.
    //1.  Use the external 8MHz crystal
    //2.  Use a divide by 2 oscillator input (4MHz in)
    //3.  Set the AHB for a prescale divide by 1
    //4.  Turn on clocks for DMA, APB, PORT A, PORT C, and TIM6
    //5.  Turn on the PLL for a multiply by 6 (24MHz system clock) and select
    //	  the PLL input source to be the crystal oscillator input
    RCC_CFGR = 0x04114002;
    RCC_CFGR2 = 0x00000001;
    RCC_AHBENR = 0x00000015;
    RCC_APB1ENR = 0x00000010;
    RCC_APB2ENR = 0x00000015;
    RCC_CR = 0x01010000;

    //Wait for the external crystal and PLL locks to be set.
    while((HSE_RDY_BIT == 0) || (PLL_RDY_BIT == 0))
        ;

    //Turn on interrupts.
    //Turn the corresponding interrupt in either of the three interrupt set enable
    //registers in the Cortex NVIC core.
    NVIC_ISER1 = 0x00400000;

    //Interrupts are on by default in the Cortex control registers.  To turn them
    //off uncomment the special assembly instruction below.  To turn them back on
    //use instruction cpsie i.
    //asm volatile
    //(
    //"cpsid i\n\t"
    //);

    //Start the application.
    main();

    //main() shouldn't return, but if it does, we'll just enter an infinite loop.
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  nmi_handler
 * Function Description:  Default NMI handler.  Override this one by defining
 * 						 your own handler routine in the application code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void nmi_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  hardfault_handler
 * Function Description:  Default hard fault handler.  Override this one by
 *  						 defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void hardfault_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  memmanage_handler
 * Function Description:  Default memory manager handler.  Override this one by
 *  						 defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void memmanage_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  busfault_handler
 * Function Description:  Default bus fault handler.  Override this one by
 *  						 defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void busfault_handler(void)
{
    while(1)
        ;
}
/*------------------------------------------------------------------------------
 * Function name:  usagefault_handler
 * Function Description:  Default usage fault handler.  Override this one by
 *  						 defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void usagefault_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  svc_handler
 * Function Description:  Default SVC handler.  Override this one by defining
 * 						 your own handler routine in the application code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void svc_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  debugmon_handler
 * Function Description:  Default debug monitor handler.  Override this one by
 *  						 defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void debugmon_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  pendsv_handler
 * Function Description:  Default pendable request for system service handler.
 *   					 Override this one by defining your own handler routine
 *   					 in the application code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void pendsv_handler(void)
{
    while(1)
        ;
}

/*------------------------------------------------------------------------------
 * Function name:  systick_handler
 * Function Description:  Default system tick timer handler.  Override this one
 *  						 by defining your own handler routine in the application
 *  						 code.
 * Parameters:  None.
 * Returns:  None.
------------------------------------------------------------------------------*/
__attribute__ ((section(".after_vectors")))
void systick_handler(void)
{
    while(1)
        ;
}

//*****************************************************************************
//
// Processor ends up here if an unexpected interrupt occurs or a specific
// handler is not present in the application code.
//
//*****************************************************************************
__attribute__ ((section(".after_vectors")))
void int_default_handler(void)
{
    while(1)
        ;
}
